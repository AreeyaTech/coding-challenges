from kivy.app import App
from kivy.uix.boxlayout import BoxLayout
from kivy.core.window import Window
from kivy.graphics import Rectangle, Ellipse, Color
from kivy.clock import Clock
from kivy.uix.label import Label
import random

BULLET_SIZE = (8, 8)
SHIP_SIZE = (20, 60)
ALIEN_SIZE = (40, 40)
WINDOW_SIZE = (600, 400)
BULLETS = 12

'''
    ---------------------------------------------
    Coding Challenge #5: Space Invaders:
    ---------------------------------------------

    This is a python version of the coding challenge from Daniel Shiffman on The Coding Train

    Original coding challenge: 
        https://www.youtube.com/watch?v=biN3v3ef-Y0&index=5&list=PLRqwX-V7Uu6ZiZxtDDRCi6uhfTH4FilpH

    Modifications:
        1)  I made the aliens start at random locations on the window

        2)  I added the bound constraints

        3)  I kept track of the score (number of aliens) and the number of bullets

'''

'''
    Checks if the point (x, y) is in the rectangle generated by the x interval [min_x, max_x]
        and the y interval [min_y, max_y]
'''
def in_bounds(x, y, min_x, max_x, min_y, max_y):
    return min_x < x < max_x and min_y < y < max_y

'''
    Class responsible for the display and update of the game
'''
class SpaceInvaders(BoxLayout):

    def __init__(self):
        super(SpaceInvaders, self).__init__()
        self.start()

    '''
        Set the default settings and initializes the parameter
    '''
    def start(self):
        Window.size = WINDOW_SIZE
        self.clear_widgets()

        # The ship will be the same throughout the whole game:
        self.ship = Ship(Window.size[0], 20)

        # keeps track of wether or not the game should restart if the user presses Enter
        self.restart = False

        # kepps track of the total time to calculate when to move the aliens
        self.total_time = 0

        # Directions of the aliens:
        #   (0, 0): No movement
        #   (1, 0): Right
        #   (-1, 0): Left
        #   (0, 1): Up
        #   (0, -1): Down
        # alien_dir keeps track of the two last directions taken by the aliens
        self.alien_dir = [(0, 0), (1, 0)]

        # Create a random number of aliens in random locations
        self.aliens = [Alien(random.randint(0, Window.size[0] - ALIEN_SIZE[0]),
                             random.randint(300, Window.size[1] - ALIEN_SIZE[1]))
                       for i in range(random.randint(5, 10))]

        # The number of bullets is 3 times the number of aliens (to make the game fair)
        self.bullets_count = 3 * len(self.aliens)

        # Outputs the number of bullets left after every shot
        self.bullets_label = Label(text="Bullets: {}".format(self.bullets_count))
        self.add_widget(self.bullets_label)

        # keeps track of the number of aliens killed
        self.aliens_killed = 0

        # keeps track of the aliens on the edge, to decide when to move down
        self.left_alien, self.right_alien = self.get_edge_aliens()

        # keeps track of the number of bullets
        self.bullets = []

        # necessary for key listener
        self.pressed_keys = set()

        # start the clock
        self.event = Clock.schedule_interval(self.update_ship, 0.05)

        # keyboard listener setup
        self._keyboard = Window.request_keyboard(self._keyboard_closed, self)
        self._keyboard.bind(on_key_down=self._on_keyboard_down)
        self._keyboard.bind(on_key_up=self._on_keyboard_up)

    '''
        Gets the indices of the aliens on the edges
    '''
    def get_edge_aliens(self):
        if len(self.aliens) > 0:
            min_index = 0
            max_index = 0
            min = self.aliens[0].x
            max = self.aliens[0].x
            for i in range(len(self.aliens)):
                if min >= self.aliens[i].x:
                    min = self.aliens[i].x
                    min_index = i
                if max <= self.aliens[i].x:
                    max = self.aliens[i].x
                    max_index = i
            return min_index, max_index
        else: return -1, -1


    '''
        Closes the listener when necessary
    '''
    def _keyboard_closed(self):
        self._keyboard.unbind(on_key_down = self._on_keyboard_down)
        self._keyboard = None

    '''
        Depending on the key, this function allows the user to move the ship
    '''
    def _on_keyboard_down(self, keyboard, keycode, text, modifiers):
        if keycode[1] == 'enter' and self.restart:
            self.start()
        else:
            self.pressed_keys.add(keycode[1])


    def _on_keyboard_up(self, keyboard, keycode):
        if not keycode[1] == 'enter':
            self.pressed_keys.remove(keycode[1])

    '''
        moves the ship, the aliens and bullets
    '''
    def update_ship(self, time):
        self.canvas.before.clear()

        self.total_time += time
        # Only move the aliens after 1 second
        if(self.total_time > 1):
            self.move_aliens(self.alien_dir)
            self.total_time = 0

        with self.canvas.before:
            # no alien, game won
            if len(self.aliens) == 0:
                self.end_game(True)

            # check the keyboard and update ship movement
            for key in self.pressed_keys:
                if self.ship.x > 0:
                    if key in ['left', 'a']: self.ship.move(-1)
                if self.ship.x < WINDOW_SIZE[0] - SHIP_SIZE[0]:
                    if key in ['right', 'd']: self.ship.move(1)
                # create bullets and save them
                if key in ['w', 'spacebar', 'up']:
                    if self.bullets_count > 0:
                        bullet = Bullet(self.ship.x + SHIP_SIZE[0] / 2 - BULLET_SIZE[0] / 2, SHIP_SIZE[1])
                        self.bullets.append(bullet)
                        self.bullets_count -= 1
                        self.bullets_label.text = "Bullets: {}".format(self.bullets_count)
            # no bullets, game over
            if len(self.bullets) == 0 and self.bullets_count == 0:
                self.end_game(False, "You ran out of bullets!")

            self.ship.show()

            Color(0, 0, 1, 1)

            # If a bullet is already out of the frame, stop keeping track of it
            for i in range(len(self.bullets) - 1, -1, -1):
                bullet = self.bullets[i]
                if(not bullet.active):
                    self.bullets.remove(bullet)
            # If not, check if it is hitting an alien, and if yes, delete both
                else:
                    alien = self.aliens_hit(bullet)
                    if(alien):
                        self.aliens.remove(alien)
                        self.left_alien, self.right_alien = self.get_edge_aliens()
                        self.bullets.remove(bullet)
                        self.aliens_killed += 1
                    else:
                        bullet.move()
                        bullet.show()

            Color(0.54, 0.17, 0.89, 1)
            for alien in self.aliens:
                alien.show()

    '''
        Moves the aliens, given thee two last directions of the aliens
    '''
    def move_aliens(self, alien_dir):
        for alien in self.aliens:
            alien.move(*alien_dir[1])
        temp = alien_dir[1]
        if len(self.aliens) > 0:
            # If the edge aliens are in bounds
            if self.aliens[self.left_alien].x <= ALIEN_SIZE[0] or self.aliens[self.right_alien].x >= WINDOW_SIZE[0] - ALIEN_SIZE[0]:
                # If the aliens went right or left, the next step should be down
                if alien_dir[1] == (1, 0) or alien_dir[1] == (-1, 0):
                    alien_dir[1] = (0, -1)
                # If the aliens went left --> down, the next step should be right
                elif alien_dir[0] == (-1, 0) and alien_dir[1] == (0, -1):
                    alien_dir[1] = (1, 0)
                # If the aliens went right --> down, the next step should be left
                elif alien_dir[0] == (1, 0) and alien_dir[1] == (0, -1):
                    alien_dir[1] = (-1, 0)

        alien_dir[0] = temp

        # check if the aliens have invaded, i.e. if they have reached the ship
        for alien in self.aliens:
            if alien.y <= 0 or \
                    in_bounds(self.ship.x + SHIP_SIZE[0] / 2, SHIP_SIZE[1], alien.x,
                    alien.x + ALIEN_SIZE[0], alien.y, alien.y + ALIEN_SIZE[1]):
                self.end_game(False, "INVASION!!!")
                return

    '''
        Displays game results and starts over, depending on the user's choice
    '''
    def end_game(self, won, message = ""):
        self.event.cancel()
        if(won):
            self.bullets_label.text = "Congratulations! You win! Press Enter to restart"
        else:
            self.bullets_label.text = "Game Over! " + message + \
            " Aliens killed: {}".format(self.aliens_killed) + \
                                        " Press Enter to restart"
        self.restart = True


    '''
        Loop through the aliens and returns the one hit by the given bullet
    '''
    def aliens_hit(self, bullet):
        for alien in self.aliens:
            # the bullet hits the alien if the bullet is in the bounds of the alien
            if in_bounds(bullet.x, bullet.y, alien.x, alien.x + ALIEN_SIZE[0], alien.y, alien.y + ALIEN_SIZE[1]):
                return alien
        return None


class SpaceInvadersApp(App):
    def build(self):
        Window.size = (600, 400)
        return SpaceInvaders()

'''
    Representation of an Alien object, providing methods
        necessary to move and display the alien
'''
class Alien:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    '''
        Move the alien by the given coordinates
    '''
    def move(self, dx, dy):
        self.x += dx * ALIEN_SIZE[0]
        self.y += dy * ALIEN_SIZE[1]

    def show(self):
        return Ellipse(pos = (self.x, self.y), size = ALIEN_SIZE)

'''
    Class representing a bullet, with behaviours such as moving the bullet
        and displaying it
'''
class Bullet:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.active = in_bounds(self.x, self.y, 0, WINDOW_SIZE[0], 0, WINDOW_SIZE[1])

    def show(self):
        return Ellipse(pos = (self.x, self.y), size = BULLET_SIZE)

    def move(self):
        self.y += 5
        self.active = in_bounds(self.x, self.y, 0, WINDOW_SIZE[0], 0, WINDOW_SIZE[1])


'''
    Class representing a ship, with behaviours such as moving the ship
        and displaying it
'''

class Ship:
    def __init__(self, width, size):
        self.x = width / 2

    def move(self, dx):
        self.x += dx * 5

    def show(self):
        return Rectangle(pos = (self.x, 0), size = SHIP_SIZE)


SpaceInvadersApp().run()
